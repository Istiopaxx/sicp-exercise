#lang sicp

;; 다음은 애커만 함수를 나타낸 프로시저다.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(A 1 10) ;; 1024 -> 2e10

(A 2 4) ;; 65536 -> 2e16

(A 3 3) ;; 65536 -> 2e16


;; 다음 프로시저를 정의하자.
;; 0보다 큰 정수 n이 있을 때, f,g,h 프로시저의 기능을 수학으로 정의해보자.

(define (k n) (* 5 n n))
;; (k n)은 5n^2를 나타낸다.

(define (f n) (A 0 n))
;; (f n)은 아커만 프로시저의 x자리의 인자가 0이므로 2n을 나타낸다.

(define (g n) (A 1 n))
;; (g n)은 아커만 프로시저의 x자리의 인자가 1이므로, 다음 아커만 프로시저의
;; 호출에서 (A 0 (A 1 (- n 1))) 이 된다. 이때 (A 1 n)꼴이 n자리가 계속 다음엔
;; (- n 1)이 들어가면서 반복되므로 결국 n이 1이 되면 y자리가 1이 되어 (A 1 1)은
;; 2가 된다. 그럼 (A 0 (A 0 (A 0......(A 0 2))...))가 되므로, 2를 n만큼 곱하게 된다.
;; 따라서 (f n)은 2^n을 나타낸다.

(define (h n) (A 2 n))
;; (A 2 n) => (A 1 (A 2 (- n 1)) => (A 1 (A 1 (A 2 (- n 2)) => ....
;; => (A 1 (A 1 (....(A 1 (A 2 1))....)
;; (A 1 (A 2 1)) => (A 1 2) => 2^2 => 4
;; (A 1 (A 1 (A 2 1)) => (A 1 4) => 2^4 => 16
;; ... 이렇게 해서 줄어든다. (A 1 (...가 n번 반복되고, 각 반복에서
;; 2^(2^(2^(...(2^(2))...)) 이런식으로 계산된다. 적절한 수식을 찾지 못하겟음..ㅜㅠ
;; 따라서 (h n)은 2^(2^(2^(...를 n번 반복하는 것을 나타낸다. 


















